/*
 * Práctica 3 - Generador AM
 * DOS SALIDAS POR SERIAL:
 * 1. {"am": [...]}     - Onda AM calculada (valores DAC convertidos a voltaje)
 * 2. {"adc": [...]}    - Lecturas directas del ADC (señal física)
 */

#include <Arduino.h> 
#include "driver/adc.h"
#include "driver/gptimer.h"
#include "driver/dac.h"
#include <math.h>

// Selección del canal DAC (GPIO 25 es DAC_CHANNEL_1)
#define DAC_CHANNEL DAC_CHANNEL_1 

// --- PINES (ESP32 DEVKIT V1) ---
const int dacPin = 25;             // Salida DAC
const int adcPin = 32;             // Entrada ADC (Retroalimentación)

// --- PARÁMETROS DE LA SEÑAL AM ---
volatile float freqP  = 1000.0f;    // Portadora (Hz)
volatile float freqM  = 100.0f;     // Moduladora (Hz)
volatile float m_index = 0.8f;      // Índice
volatile float A_c    = 1.0f;

// --- CONFIGURACIÓN CRÍTICA DE TIEMPO ---
#define SAMPLE_RATE_HZ      50000UL  // 50 kHz para ~50 puntos por ciclo de 1 kHz

const int NUM_DATOS_JSON = 50;  // Muestras por paquete JSON (envío)
const int DECIMATOR = 10;       // Guardar 1 de cada 10 muestras para enviar (DAC sigue a SAMPLE_RATE_HZ)

// Handles de Tareas
TaskHandle_t samplingTaskHandle = NULL;
TaskHandle_t commTaskHandle = NULL;

// Buffer de envío (doble buffer simple)
volatile bool sendSlotReady = false;
float sendSlotAM[NUM_DATOS_JSON];
float sendSlotADC[NUM_DATOS_JSON];

// Sistema Timer
gptimer_handle_t gptimer = NULL;
portMUX_TYPE timerMux = portMUX_INITIALIZER_UNLOCKED;

// --- VARIABLES DE GENERACIÓN DE ONDA ---
float phaseP = 0.0f;
float phaseM = 0.0f;
const float DOS_PI = 6.28318530718f;

// Prototipos
bool IRAM_ATTR onTimer(gptimer_handle_t timer, const gptimer_alarm_event_data_t *edata, void *user_ctx);
void procesarComando(const String &cmd);
void taskSampling(void *param);
void taskComm(void *param);

void setup() {
    Serial.begin(115200);
    while (!Serial) { delay(10); }

    // Configuración explícita del pin de entrada para asegurar lectura
    pinMode(adcPin, INPUT);
    analogReadResolution(12);

    // Inicialización del DAC
    dac_output_enable(DAC_CHANNEL);
    dac_output_voltage(DAC_CHANNEL, 0);

    // Configuración del Timer (1MHz)
    gptimer_config_t timer_config = {
        .clk_src       = GPTIMER_CLK_SRC_DEFAULT,
        .direction     = GPTIMER_COUNT_UP,
        .resolution_hz = 1000000UL
    };
    gptimer_new_timer(&timer_config, &gptimer);

    // Alarma basada en SAMPLE_RATE_HZ
    gptimer_alarm_config_t alarm_config = {
        .alarm_count  = (uint64_t)(1000000UL / SAMPLE_RATE_HZ),
        .reload_count = 0,
        .flags = { .auto_reload_on_alarm = true }
    };
    gptimer_set_alarm_action(gptimer, &alarm_config);

    gptimer_event_callbacks_t cbs = {
        .on_alarm = onTimer
    };
    gptimer_register_event_callbacks(gptimer, &cbs, NULL);

    gptimer_enable(gptimer);
    gptimer_start(gptimer);

    // Crear Tareas
    // Core 0: generación (alta prioridad)
    xTaskCreatePinnedToCore(taskSampling, "samplingTask", 8192, NULL, 4, &samplingTaskHandle, 0);
    // Core 1: comunicación (baja prioridad)
    xTaskCreatePinnedToCore(taskComm, "commTask", 6144, NULL, 1, &commTaskHandle, 1);

    Serial.println("--- Generador AM: 2 Salidas (AM/ADC) ---");
}

// --- TAREA DE COMUNICACIÓN (Core 1) ---
void taskComm(void *param) {
    static char linea[640];
    float localAM[NUM_DATOS_JSON];
    float localADC[NUM_DATOS_JSON];

    for (;;) {
        ulTaskNotifyTake(pdTRUE, portMAX_DELAY);
        if (!sendSlotReady) continue;

        portENTER_CRITICAL(&timerMux);
            for (int i = 0; i < NUM_DATOS_JSON; i++) {
                localAM[i]  = sendSlotAM[i];
                localADC[i] = sendSlotADC[i];
            }
            sendSlotReady = false;
        portEXIT_CRITICAL(&timerMux);

        int idx = 0;
        idx += snprintf(linea + idx, sizeof(linea) - idx, "{\"am\":[");
        for (int i = 0; i < NUM_DATOS_JSON; i++) {
            idx += snprintf(linea + idx, sizeof(linea) - idx, "%.3f%s", localAM[i], (i == NUM_DATOS_JSON - 1) ? "" : ",");
        }
        idx += snprintf(linea + idx, sizeof(linea) - idx, "],\"adc\":[");
        for (int i = 0; i < NUM_DATOS_JSON; i++) {
            idx += snprintf(linea + idx, sizeof(linea) - idx, "%.3f%s", localADC[i], (i == NUM_DATOS_JSON - 1) ? "" : ",");
        }
        idx += snprintf(linea + idx, sizeof(linea) - idx, "]}");
        Serial.println(linea);
    }
}

void loop() {
    if (Serial.available()) {
        String cmd = Serial.readStringUntil('\n');
        cmd.trim();
        if (cmd.length() > 0) {
            procesarComando(cmd);
        }
    }
}

// --- ISR DEL TIMER ---
bool IRAM_ATTR onTimer(gptimer_handle_t timer, const gptimer_alarm_event_data_t *edata, void *user_ctx) {
    BaseType_t hpTaskWoken = pdFALSE;
    vTaskNotifyGiveFromISR(samplingTaskHandle, &hpTaskWoken);
    return (hpTaskWoken == pdTRUE);
}

void procesarComando(const String &cmd) {
    int separator = cmd.indexOf('=');
    if (separator > 0) {
        String param = cmd.substring(0, separator);
        float value = cmd.substring(separator + 1).toFloat();
        
        portENTER_CRITICAL(&timerMux);
        if (param.equalsIgnoreCase("FP")) freqP = value;
        else if (param.equalsIgnoreCase("FM")) freqM = value;
        else if (param.equalsIgnoreCase("IDX")) {
            m_index = value;
            if (m_index < 0.0f) m_index = 0.0f;
        }
        else if(param.equalsIgnoreCase("AC")) A_c = value;
        portEXIT_CRITICAL(&timerMux);
    }
}

// --- TAREA DE MUESTREO Y GENERACIÓN ---
void taskSampling(void *param) {
    static int conteoJson = 0;
    static float vAM[NUM_DATOS_JSON];
    static float vADC[NUM_DATOS_JSON];
    static int envioCounter = 0;
    const int ENVIO_RATE = 5;  // Enviar con mayor frecuencia
    
    while (true) {
        ulTaskNotifyTake(pdTRUE, portMAX_DELAY);
        
        // 1. GENERACIÓN AM
        portENTER_CRITICAL(&timerMux); 
            float stepP = (DOS_PI * freqP) / SAMPLE_RATE_HZ;
            float stepM = (DOS_PI * freqM) / SAMPLE_RATE_HZ;
            
            phaseP += stepP; 
            phaseM += stepM; 
            
            if (phaseP > DOS_PI) phaseP -= DOS_PI; 
            if (phaseM > DOS_PI) phaseM -= DOS_PI; 
            
            float local_pP = phaseP;
            float local_pM = phaseM;
            float local_idx = m_index;
        portEXIT_CRITICAL(&timerMux); 

        float mod = sinf(local_pM); 
        float car = sinf(local_pP); 
        float raw_am = ((1.0f + local_idx * mod) * car) / (1.0f + local_idx); 
        int dacValue = (int)((raw_am + 1.0f) * 127.5f);
        
        if (dacValue < 0) dacValue = 0;
        else if (dacValue > 255) dacValue = 255;

        dac_output_voltage(DAC_CHANNEL, (uint8_t)dacValue);  
        
        // 2. LECTURA ADC (señal física)
        int adcRaw = analogRead(adcPin); 

        

        // 4. RECOLECCIÓN DE DATOS PARA SERIAL (decimado)
        static int decimator = 0;
        decimator++;
        
        if (decimator >= DECIMATOR) { // tomar 1 de cada N muestras para envío; DAC sigue a SAMPLE_RATE_HZ
            decimator = 0;
            
            envioCounter++;  // Contador para control de envío
            
            if (conteoJson < NUM_DATOS_JSON) {
                vAM[conteoJson] = (dacValue / 255.0f) * 3.3f;
                vADC[conteoJson] = (adcRaw / 4095.0f) * 3.3f;
                conteoJson++;
            }
        }

        // 5. PASAR BUFFER A LA TAREA DE COMUNICACIÓN
        if (conteoJson >= NUM_DATOS_JSON && envioCounter >= ENVIO_RATE && !sendSlotReady) {
            envioCounter = 0;
            portENTER_CRITICAL(&timerMux);
                for (int i = 0; i < NUM_DATOS_JSON; i++) {
                    sendSlotAM[i]  = vAM[i];
                    sendSlotADC[i] = vADC[i];
                }
                sendSlotReady = true;
                conteoJson = 0;
            portEXIT_CRITICAL(&timerMux);
            xTaskNotifyGive(commTaskHandle);
        }
        // 6. FIN DEL CICLO
    }
}
